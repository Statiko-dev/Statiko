trigger:
  - master

resources:
  - repo: self

variables:
  # Go
  GOVERSION: '1.12'
  GOROOT: '/usr/local/go$(GOVERSION)'
  GOPATH: '/home/vsts/go'

  # Container registry service connection established during pipeline creation
  dockerRegistryServiceConnection: 'a041da97-3f29-4781-a417-751b98eb7903'
  imageRepository: 'italypaleale/smplatform'
  containerRegistry: 'hub.docker.com'
  dockerfilePath: '$(Build.SourcesDirectory)/container/Dockerfile'
  dockerTag: '$(Build.BuildNumber)'
  testDockerfilePath: '$(Build.SourcesDirectory)/e2e-test/Dockerfile'
  coverageDockerfilePath: '$(Build.SourcesDirectory)/e2e-test/Dockerfile-coverage'
  testImageRepository: 'smplatform-test'

stages:
  - stage: build
    displayName: Build SMPlatform artifacts
    jobs:
      - job: build
        displayName: Build artifacts for Linux (amd64, arm64, armhf)
        pool:
          vmImage: ubuntu-16.04
        steps:
          # Install required packages
          - bash: |
              sudo apt-get update && \
              sudo apt-get install -y \
                build-essential \
                crossbuild-essential-armhf \
                crossbuild-essential-arm64 \
                autoconf \
                libtool \
                cmake \
                pkg-config \
                git \
                automake \
                autogen \
                ca-certificates \
                clang \
                llvm-dev \
                libtool \
                libxml2-dev \
                uuid-dev \
                libssl-dev \
                swig \
                patch \
                make \
                xz-utils \
                cpio \
                sqlite
            displayName: "Install required packages"
          # Set up go environment
          - bash: |
              set -e

              # Add to GOBIN to PATH
              echo '##vso[task.prependpath]$(GOBIN)'
              echo '##vso[task.prependpath]$(GOROOT)/bin'
            displayName: "Set up go environment"
          # Build amd64
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              GO111MODULE=on \
              GOFLAGS=-mod=vendor \
                go build \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$(date -u +'%Y-%m-%dT%H:%M:%S') -X smplatform/buildinfo.CommitHash=$(git log --pretty=format:'%h' -n 1)" \
                  -o bin/smplatform_linux_amd64
            displayName: "Build amd64"
          # Build amd64 with coverage
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              GO111MODULE=on \
              GOFLAGS=-mod=vendor \
                go test \
                  -coverpkg=smplatform/... \
                  -c \
                  -tags e2etests \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$(date -u +'%Y-%m-%dT%H:%M:%S') -X smplatform/buildinfo.CommitHash=$(git log --pretty=format:'%h' -n 1)" \
                  -o bin/smplatform_linux_amd64.test
            displayName: "Build amd64 with coverage"
          # Build arm64
          # Only run on master
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              CC=aarch64-linux-gnu-gcc-5 \
              CXX=aarch64-linux-gnu-g++-5 \
              GO111MODULE=on \
              GOFLAGS=-mod=vendor \
              GOOS=linux \
              GOARCH=arm64 \
              CGO_ENABLED=1 \
                go build \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$(date -u +'%Y-%m-%dT%H:%M:%S') -X smplatform/buildinfo.CommitHash=$(git log --pretty=format:'%h' -n 1)" \
                  -o bin/smplatform_linux_arm64
            displayName: "Build arm64"
            condition: "and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))"
          # Build armhf
          # Only run on master
          - bash: |
              set -e

              BUILD_ID=$(Build.BuildNumber)
              BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%S')
              COMMIT_HASH=$(git log --pretty=format:'%h' -n 1)

              CC=arm-linux-gnueabihf-gcc-5 \
              CXX=arm-linux-gnueabihf-g++-5 \
              GO111MODULE=on \
              GOFLAGS=-mod=vendor \
              GOOS=linux \
              GOARCH=arm \
              GOARM=7 \
              CGO_ENABLED=1 \
                go build \
                  -ldflags "-X smplatform/buildinfo.ENV=production -X smplatform/buildinfo.BuildID=$BUILD_ID -X smplatform/buildinfo.BuildTime=$(date -u +'%Y-%m-%dT%H:%M:%S') -X smplatform/buildinfo.CommitHash=$(git log --pretty=format:'%h' -n 1)" \
                  -o bin/smplatform_linux_armhf
            displayName: "Build armhf"
            condition: "and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))"
          # Copy binaries to the artifacts staging directory
          - task: CopyFiles@2
            displayName: Copy binaries to the artifacts staging directory
            inputs:
              sourceFolder: 'bin/'
              contents: '**/*'
              targetFolder: '$(Build.ArtifactStagingDirectory)'
          # Publish binaries as artifacts
          - task: PublishBuildArtifacts@1
            displayName: 'Publish build artifacts'
            inputs:
              artifactName: drop
  
  # Build Docker container and run test for amd64
  - stage: docker
    displayName: Containerize and test
    dependsOn: build
    jobs:
      - job: docker
        displayName: Containerize and test
        strategy:
          matrix:
            amd64:
              AGENT_POOL: 'Hosted Ubuntu 1604'
              BUILD_ARCH: amd64
              NODE_ARCH: x64
            armhf:
              AGENT_POOL: 'armhf'
              BUILD_ARCH: armhf
              NODE_ARCH: armv7l
        pool: $(AGENT_POOL)
        steps:
          # Download build artifacts from previous stage
          - task: DownloadBuildArtifacts@0
            displayName: Download build artifacts
            inputs:
              buildType: current
              artifactName: drop
              downloadPath: '$(Build.ArtifactStagingDirectory)'
              condition: "and(succeeded(), or(eq(variables['BUILD_ARCH'], 'amd64'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))"
          # Copy binaries from the artifacts staging directory
          - task: CopyFiles@2
            displayName: Copy binaries from the artifacts staging directory
            inputs:
              sourceFolder: '$(Build.ArtifactStagingDirectory)/drop'
              contents: '**/*'
              targetFolder: 'bin/'
            condition: "and(succeeded(), or(eq(variables['BUILD_ARCH'], 'amd64'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))"
          # Build Docker image
          - task: Docker@2
            displayName: Build Docker image
            inputs:
              command: build
              buildContext: $(Build.SourcesDirectory)
              repository: $(imageRepository)
              dockerfile: $(dockerfilePath)
              containerRegistry: $(dockerRegistryServiceConnection)
              arguments: |
                --build-arg ARCH=$(BUILD_ARCH)
              tags: |
                latest
                latest-linux-$(BUILD_ARCH)
                $(dockerTag)-linux-$(BUILD_ARCH)
            condition: "and(succeeded(), or(eq(variables['BUILD_ARCH'], 'amd64'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))"
          # Build Docker test image with coverage
          # Run this on amd64 only
          - bash: |
              set -e
              mkdir e2e-test/bin
              cp bin/*.test e2e-test/bin
              docker build \
                -f $(coverageDockerfilePath) \
                -t $(testImageRepository) \
                --build-arg ARCH=$(BUILD_ARCH) \
                --build-arg NODE_ARCH=$(NODE_ARCH) \
                $(Build.SourcesDirectory)/e2e-test
            displayName: Build Docker test image with coverage
            condition: and(succeeded(), eq(variables['BUILD_ARCH'], 'amd64'))
          # Build Docker test image
          # Run this on archs different from amd64
          - bash: |
              docker build \
                -f $(testDockerfilePath) \
                -t $(testImageRepository) \
                --build-arg ARCH=$(BUILD_ARCH) \
                --build-arg NODE_ARCH=$(NODE_ARCH) \
                $(Build.SourcesDirectory)/e2e-test
            displayName: Build Docker test image
            condition: and(succeeded(), ne(variables['BUILD_ARCH'], 'amd64'), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
          # Run end-to-end tests
          - bash: |
              set -e
              docker run \
                --rm \
                -v $(pwd)/e2e-test/container_etc:/etc/smplatform \
                -v $(pwd)/e2e-test/results:/results \
                -e "AZURE_STORAGE_SAS_TOKEN=$(AZURE_STORAGE_SAS_TOKEN)" \
                -e "AZURE_CLIENT_SECRET=$(AZURE_CLIENT_SECRET)" \
                -e "NODE_URL=smplatform.local:3000" \
                -e "NGINX_URL=smplatform.local" \
                --add-host "smplatform.local:127.0.0.1" \
                $(testImageRepository)
            displayName:  Run end-to-end tests
            condition: and(succeeded(), or(eq(variables['BUILD_ARCH'], 'amd64'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))
          # Publish test results
          - task: PublishTestResults@2
            displayName: Publish test results
            inputs:
              testRunner: JUnit
              testResultsFiles: e2e-test/results/junit.xml
            condition: and(succeededOrFailed(), or(eq(variables['BUILD_ARCH'], 'amd64'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))
          # Get coverage tools
          # Run this on amd64 only
          - task: UniversalPackages@0
            inputs:
              command: download
              downloadDirectory: $(System.DefaultWorkingDirectory)/bin/
              vstsFeed: go-binaries
              vstsFeedPackage: 'coverage-linux-amd64'
              vstsPackageVersion: 1.0.0
            displayName: Get coverage tools
            condition: and(succeeded(), eq(variables['BUILD_ARCH'], 'amd64'))
          # Convert coverage results
          # Run this on amd64 only
          - bash: |
              set -e
              chmod +x ./bin/gocov*
              sudo chmod 0777 e2e-test/results
              sudo chmod 0666 e2e-test/results/*
              ./bin/gocov convert e2e-test/results/coverage.out | ./bin/gocov-xml > e2e-test/results/coverage.xml
            displayName: Convert coverage results
            condition: and(succeeded(), eq(variables['BUILD_ARCH'], 'amd64'))
          # Publish coverage results
          # Run this on amd64 only
          - task: PublishCodeCoverageResults@1
            inputs: 
              codeCoverageTool: Cobertura
              summaryFileLocation: $(Build.SourcesDirectory)/e2e-test/results/coverage.xml
            displayName: Publish coverage results
            condition: and(succeeded(), eq(variables['BUILD_ARCH'], 'amd64'))
          # Push Docker image to container registry
          # Only run on master
          - task: Docker@2
            condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
            displayName: Push Docker image to container registry
            inputs:
              command: push
              repository: $(imageRepository)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                latest-linux-$(BUILD_ARCH)
                $(dockerTag)-linux-$(BUILD_ARCH)
          # Post-build cleanup
          - bash: |
              # Delete files from disk
              rm -rvf $(Agent.BuildDirectory) || true
              rm -rvf $(Build.SourcesDirectory) || true
              rm -rvf $(Build.ArtifactStagingDirectory) || true
              # Remove Docker images
              docker rmi -f $(docker images -q) || true
            displayName: "Post-build cleanup"
            # This step always runs, even if the pipeline failed
            condition: always()
